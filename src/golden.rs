//! The golden test runner.
//!
//! To see the output of this runner when `cargo test`ing, pass the flag `--show-output`.
//! If you'd like to only run golden tests, execute `cargo t golden -- --show-output`.
//!
//! ## Gilding
//!
//! In the case where the golden output is no longer considered up to date, one can choose
//! to overwrite it by so-called "gilding" the actual output of a test.
//! This can either be done by specifying a comma-separated list of test files through the
//! environment variable `GILD` or update all (failing) tests by defining the environment
//! variable `GILD_ALL_FAILING`.
//!
//! ### Examples
//!
//! Guild `tests/alpha.lushui` and `tests/path/to/beta.lushui`:
//!
//! ```sh
//! GILD='alpha,path/to/beta' cargo t golden -- --show-output
//! ```
//!
//! ```sh
//! GILD_ALL_FAILING= cargo t golden -- --show-output
//! ```
//!
//! Gilding is the same as manually deleting the stderr and stdout files and afterwards re-running
//! the golden tester to let it generate the files with up to date content.
//!
//! ## Writing Tests
//!
//! A test in the context of this golden test runner is a lushui source file placed into `tests/` or
//! any of its subdirectories. Each source file should be accompanied by two other files identical in
//! name apart from their extension â€” `stdout` and `stderr`. Those two are the respective test oracle.
//! They are generated by a test run from the actual output of the compiler if they are not provided.
//!
//! Each lushui source code file has to have a test header being `;;; TEST ` plus the test configuration.
//! The first mandatory argument must be one of the following: `ignore`, `pass` or `fail`. The remaining
//! arguments are passed as-is to the lushui binary.
//!
//! ## Pending Tasks
//!
//! * improve error reporting (printing `Error`s)
//! * make it possible to escape dollar signs in golden stderr files
//! * (not strictly related to this runner) create more relevant tests
//! * somehow prevent test writers from adding golden stderr files which
//!   don't use `${DIRECTORY}` but a local path
//! * print information after each golden file for increased responsiveness
//! * maybe implement filtering golden directories and files
//! * use `rayon` to test in parallel

use crate::{has_file_extension, span::SourceMap, HashMap};
use colored::Colorize;
use std::{
    default::default,
    fmt,
    fs::{read_to_string, File},
    io::Write,
    path::Path,
    process::Command,
};

const TEST_DIRECTORY_NAME: &str = "tests";
const GOLDEN_STDERR_VARIABLE_DIRECTORY: &str = "${DIRECTORY}";

#[test]
fn run() -> Result<(), Error> {
    let gild_all_failing = std::env::var("GILD_ALL_FAILING").is_ok();
    let files_to_be_gilded = std::env::var("GILD").unwrap_or_default();
    let files_to_be_gilded = files_to_be_gilded.split(',').collect::<Vec<_>>();
    // @Task add filtering via env "FILTER=thing0,thing1,..." and think about its
    // relatation with GILD and GILD_ALL_FAILING

    let mut map = SourceMap::default();

    let badge_ok = "ok".green();
    let badge_failed = "FAILED".red();
    let badge_ignored = "ignored".yellow();

    let mut number_of_ignored_tests = 0u32;
    let mut number_of_passed_tests = 0u32;
    let mut number_of_failed_tests = 0u32;

    let mut failures: HashMap<String, Vec<Failure>> = default();

    let test_directory_path = Path::new(env!("CARGO_MANIFEST_DIR")).join(TEST_DIRECTORY_NAME);
    let readable_test_directory_path = test_directory_path.to_str().unwrap();

    for dir_entry in walkdir::WalkDir::new(&test_directory_path) {
        let entry = dir_entry.map_err(Error::InvalidTestsDirectoryEntry)?;

        if !entry.file_type().is_file() {
            continue;
        }

        // handled later together with the corresponding lushui file
        if has_file_extension(entry.path(), "stdout") || has_file_extension(entry.path(), "stderr")
        {
            continue;
        }

        let readable_path = entry.path().to_str().ok_or(Error::IllegalTestFileName)?;
        let readable_path = readable_path
            .strip_prefix(readable_test_directory_path)
            .unwrap()
            .strip_prefix('/')
            .unwrap()
            .strip_suffix(&format!(".{}", crate::FILE_EXTENSION))
            .unwrap();

        print!("test {:>60} ", readable_path);

        // @Beacon @Task don't use SourceMap for this, just raw File
        let file = map
            .load(entry.path().to_owned())
            .map_err(|_| Error::FailedLoadingSourceFile)?;
        let file = map.get(file);

        let config =
            TestConfiguration::parse(file.content()).map_err(Error::InvalidTestFileHeader)?;

        if config.tag == TestTag::Ignore {
            number_of_ignored_tests += 1;
            println!("{}", badge_ignored);
            continue;
        }

        let time = std::time::Instant::now();

        // @Beacon @Task if rustc/cargo emits warnings, don't keep them around!
        let output = Command::new("cargo")
            .args(&["run", "-q", "--"])
            .arg("--sort-diagnostics") // for deterministic output
            .args(config.program_arguments)
            .arg(entry.path())
            .output()
            .map_err(Error::FailedRunningCompilerProcess)?;

        let duration = time.elapsed();

        let failures = failures.entry(readable_path.to_owned()).or_default();

        match config.tag {
            TestTag::Pass => {
                if !output.status.success() {
                    failures.push(Failure::UnexpectedFail {
                        code: output.status.code(),
                    });
                }
            }
            TestTag::Fail => {
                if output.status.success() {
                    failures.push(Failure::UnexpectedPass);
                }
            }
            TestTag::Ignore => unreachable!(),
        }

        let gilding = gild_all_failing || files_to_be_gilded.contains(&readable_path);

        if let Err(error) = check_against_golden(
            readable_test_directory_path,
            &entry.path().with_extension("stdout"),
            output.stdout,
            Stream::Stdout,
            gilding,
        )? {
            failures.push(error);
        }

        if let Err(error) = check_against_golden(
            readable_test_directory_path,
            &entry.path().with_extension("stderr"),
            output.stderr,
            Stream::Stderr,
            gilding,
        )? {
            failures.push(error);
        }

        let badge = if failures.is_empty() {
            number_of_passed_tests += 1;
            &badge_ok
        } else {
            number_of_failed_tests += 1;
            &badge_failed
        };

        println!("{badge:<7} {}", format!("{duration:.2?}").bright_black());
    }

    for (path, file_failures) in failures {
        if file_failures.is_empty() {
            continue;
        }

        println!();
        println!("---- {} ----", path);
        println!();

        for file_failure in file_failures {
            println!("{}", file_failure);
        }
    }

    let number_of_recognized_tests = number_of_passed_tests + number_of_failed_tests;
    let number_of_tests = number_of_recognized_tests + number_of_ignored_tests;
    let ratio_of_success_versus_recognized_tests = 100.0
        * match number_of_passed_tests {
            0 => 1.0,
            passed => passed as f32 / number_of_recognized_tests as f32,
        };

    let golden_tests_failed = number_of_failed_tests != 0;

    println!();
    println!(
        "golden test result: {}. {} total. {} passed ({:.2}%); {} failed; {} ignored",
        if golden_tests_failed {
            badge_failed
        } else {
            badge_ok
        },
        number_of_tests,
        number_of_passed_tests,
        ratio_of_success_versus_recognized_tests,
        number_of_failed_tests,
        number_of_ignored_tests
    );

    if golden_tests_failed {
        return Err(Error::TestsFailed);
    }

    Ok(())
}

fn check_against_golden(
    test_directory_path: &str,
    golden: &Path,
    actual: Vec<u8>,
    stream: Stream,
    gilding: bool,
) -> Result<Result<(), Failure>, Error> {
    let actual = String::from_utf8(actual).unwrap();
    let golden_file_already_exists = golden.exists();
    let mut mismatch = false;

    if golden_file_already_exists {
        let golden = read_to_string(golden).map_err(Error::GoldenFileInaccessible)?;
        let golden = stream.preprocess_before_comparison(golden, test_directory_path);
        mismatch = actual != golden;

        if mismatch && !gilding {
            return Ok(Err(Failure::GoldenFileMismatch {
                golden,
                actual,
                stream,
            }));
        }
    }

    if mismatch && gilding {
        print!("{} {}, ", stream.to_string().blue(), "gilded".blue());
    }

    if !golden_file_already_exists || gilding {
        let actual = stream.preprocess_before_generating(actual, test_directory_path);

        File::create(golden)
            .map_err(Error::UnableToCreateGoldenFile)?
            .write_all(&actual.as_bytes())
            .unwrap();

        if !gilding {
            print!("{} {}, ", stream.to_string().blue(), "generated".blue());
        }
    }

    Ok(Ok(()))
}

#[derive(Clone, Copy)]
enum Stream {
    Stdout,
    Stderr,
}

impl Stream {
    fn preprocess_before_comparison(self, stream: String, test_directory_path: &str) -> String {
        match self {
            Self::Stdout => stream,
            // @Task don't replace if preceeded by another `$` (and replace `$$` with `$` in a second step)
            Self::Stderr => stream.replace(GOLDEN_STDERR_VARIABLE_DIRECTORY, test_directory_path),
        }
    }

    fn preprocess_before_generating(self, stream: String, test_directory_path: &str) -> String {
        match self {
            Self::Stdout => stream,
            Self::Stderr => stream.replace(test_directory_path, GOLDEN_STDERR_VARIABLE_DIRECTORY),
        }
    }
}

impl fmt::Display for Stream {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Stdout => write!(f, "stdout"),
            Self::Stderr => write!(f, "stderr"),
        }
    }
}

enum Failure {
    UnexpectedPass,
    UnexpectedFail {
        code: Option<i32>,
    },
    GoldenFileMismatch {
        golden: String,
        actual: String,
        stream: Stream,
    },
}

impl fmt::Display for Failure {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}: ", "test failure".red().bold())?;
        match self {
            Self::UnexpectedPass => {
                write!(f, "expected test to fail but compiler exited successfully")?
            }
            Self::UnexpectedFail { code } => {
                write!(f, "expected test to pass but compiler failed")?;
                if let Some(code) = code {
                    write!(f, " with exit code {}", code)?;
                }
            }
            Self::GoldenFileMismatch {
                golden,
                actual,
                stream,
            } => {
                writeln!(
                    f,
                    "{stream} of the compiler does not match the golden {stream}:",
                    stream = stream
                )?;

                // @Task @Note i think we need to handle the case where only whitespace differs
                // separately for a more intellible error message
                writeln!(f, "{}", difference::Changeset::new(golden, actual, "\n"))?;
            }
        }

        Ok(())
    }
}

struct TestConfiguration<'a> {
    tag: TestTag,
    program_arguments: Vec<&'a str>,
}

impl<'a> TestConfiguration<'a> {
    fn parse(source: &'a str) -> Result<Self, ParseError> {
        use ParseError::*;

        const PREFIX: &str = ";;; TEST ";

        let arguments = source
            .lines()
            .next()
            .and_then(|line| line.strip_prefix(PREFIX))
            .ok_or(MissingPrefix)?;

        let mut arguments = arguments.split_ascii_whitespace();

        let tag = arguments.next().ok_or(MissingArgument)?;

        Ok(TestConfiguration {
            tag: match tag {
                "ignore" => TestTag::Ignore,
                "pass" => TestTag::Pass,
                "fail" => TestTag::Fail,
                tag => return Err(InvalidArgument(tag.to_owned())),
            },
            program_arguments: arguments.collect(),
        })
    }
}

#[derive(PartialEq, Eq)]
enum TestTag {
    Ignore,
    Pass,
    Fail,
}

#[derive(Debug)]
enum ParseError {
    MissingPrefix,
    MissingArgument,
    InvalidArgument(String),
}

impl fmt::Display for ParseError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::MissingPrefix => write!(f, "missing prefix"),
            Self::MissingArgument => write!(f, "missing argument"),
            Self::InvalidArgument(argument) => write!(f, "invalid argument `{}`", argument),
        }
    }
}

use std::io;

enum Error {
    InvalidTestsDirectoryEntry(walkdir::Error),
    // @Task add file name
    IllegalTestFileName,
    // @Task add cause (need to change signature of span::SourceMap::load
    //from ret. Diag. to a custom Error)
    FailedLoadingSourceFile,
    // @Task add filename
    InvalidTestFileHeader(ParseError),
    // @Task add filename and stream
    UnableToCreateGoldenFile(io::Error),
    // @Task add filename
    GoldenFileInaccessible(io::Error),
    FailedRunningCompilerProcess(io::Error),
    TestsFailed,
}

impl fmt::Debug for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use Error::*;

        let message = match self {
            InvalidTestsDirectoryEntry(error) => format!(
                "an entry of the tests/ directory is not valid because {}",
                error
            ),
            IllegalTestFileName => format!("the file name of a test file is illegal"),
            FailedLoadingSourceFile => format!("failed to load a lushui source file because: ?"),
            InvalidTestFileHeader(error) => {
                format!("the header of a test file is not valid because {}", error)
            }
            UnableToCreateGoldenFile(error) => {
                format!("unable to create golden file because {}", error)
            }
            GoldenFileInaccessible(error) => {
                format!("unable to read golden file because {}", error)
            }
            FailedRunningCompilerProcess(error) => {
                format!("failed to run the compiler as a process because {}", error)
            }
            TestsFailed => format!("some golden tests failed"),
        };

        write!(f, "{}", message.bright_red().bold())
    }
}
