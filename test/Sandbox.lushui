;;; Our sandbox
'data Nat: 'Type =
    Zero: Nat
    Succ: Nat -> Nat 

'let x: 'Type = 'Type

'let the (A: 'Type) (x: A): A = x

'let two: Nat = Succ (Succ Zero)

'let n: Nat = the Nat (Succ (Succ Zero))
'let T: 'Type = 'Type


;;; we need more information when substituting!!!
;;; look:

;;; here, we can substitute the parameter with the argument
'let function (parameter: Nat): Nat = parameter

;;; but here, we 'lost' information:
'let function': Nat -> Nat = function
;;; we cannot substitute anymore

;;; similar case but now f is a parameter
'let apply (A: 'Type) (f: A -> A) (x: A): A = f x

;;; 'let x': Nat = apply Nat function Zero
'let x': Nat = apply Nat function' Zero

'let the_nat: Nat -> Nat = the Nat

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

'data Bool: 'Type =
    False: Bool
    True: Bool

'let constant (A B: 'Type) (a: A) (b: B): A = a

'let does_it_reduce_under_param (b: Bool): Bool = constant Bool Bool False b
