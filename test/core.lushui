;; @Task implement the concept of crates and make `core` (this) a crate

identity (A: Type) (a: A): A = a

constant (A B: Type) (a: A) (b: B): A = a

compose (A B C: Type) (f: A -> B) (g: B -> C) (a: A): C =
    g (f a)

flip (A B C: Type) (f: A -> B -> C) (b: B) (a: A): C =
    f a b

module void: =
    data Void: Type =

    ;; absurd (A: Type) (v: Void): A =
    ;;     case v of

module unit: =
    @inherent
    data Unit: Type =
        unit: Unit

module bool: =
    @inherent
    data Bool: Type =
        false: Bool
        true: Bool
    
    ;; not (b: Bool): Bool =
    ;;     case b of
    ;;         false => true
    ;;         true => false
    
    ;; @Note not lazy
    ;; if (A: Type) (condition: Bool) (consequent alternate: A): A =
    ;;     case condition of
    ;;         false => alternate
    ;;         true => consequent

    ;; @Note not lazy
    ;; and (b c: Bool): Bool = if Bool b c false

    ;; or (b c: Bool): Bool = if Bool b True c

module text: =
    @foreign
    data Text: Type

    @foreign
    concat: Text -> Text -> Text

module nat: =
    use super.option.Option
    use super.bool.Bool
    use super.text.Text

    @foreign
    data Nat: Type

    @foreign
    add: Nat -> Nat -> Nat

    @foreign
    subtract: Nat -> Nat -> Option Nat

    @foreign
    multiply: Nat -> Nat -> Nat
    
    @foreign
    divide: Nat -> Nat -> Option Nat

    @foreign
    equal: Nat -> Nat -> Bool

    @foreign
    less: Nat -> Nat -> Bool

    @foreign
    less-equal: Nat -> Nat -> Bool

    @foreign
    greater: Nat -> Nat -> Bool

    @foreign
    greater-equal: Nat -> Nat -> Bool

    @foreign
    display: Nat -> Text

module duple: =
    ;; @Task make inherent as well
    data Duple (A B: Type): Type =
        duple (A B: Type): A -> B -> Duple A B

module triple: =
    data Triple (A B C: Type): Type =
        triple (A B C: Type): A -> B -> C -> Triple A B C

module option: =
    @inherent
    data Option (A: Type): Type =
        none (A: Type): Option A
        some (A: Type): A -> Option A

    ;; map (A B: Type) (f: A -> B) (a: Option A): Option B =
    ;;     case a of
    ;;         some ?A ?a => some B (f a)
    ;;         none ?A => none B

module result: =
    data Result (A E: Type): Type =
        failure (A E: Type): E -> Result A E
        success (A E: Type): A -> Result A E

module list: =
    data List (A: Type): Type =
        ;; @bad naming
        nil (A: Type): List A
        cons (A: Type): A -> List A -> List A
