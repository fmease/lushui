;; @Task implement the concept of crates and make `core` (this) a crate

identity (A: Type) (a: A): A = a

constant (A B: Type) (a: A) (b: B): A = a

;; @Bug @Bug @Beacon regression: a pi-type w/o a parameter is no longer equal to
;; to a pi-type with one:
;; error[E032]: mismatched types. expected `(A) -> (C)`, got `(x: A) -> (C)`
;; compose (A B C: Type) (f: A -> B) (g: B -> C) (a: A): C =
;;     g (f a)

module void: =
    data Void: Type =

    ;; absurd (A: Type) (v: Void): A =
    ;;     case v of

module unit: =
    _inherent_
    data Unit: Type =
        unit: Unit

module bool: =
    _inherent_
    data Bool: Type =
        false: Bool
        true: Bool
    
    ;; not (b: Bool): Bool =
    ;;     case b of
    ;;         false => true
    ;;         true => false
    
    ;; @Note not lazy
    ;; if (A: Type) (condition: Bool) (consequent alternate: A): A =
    ;;     case condition of
    ;;         false => alternate
    ;;         true => consequent

    ;; @Note not lazy
    ;; and (b c: Bool): Bool = if Bool b c false

    ;; or (b c: Bool): Bool = if Bool b True c

module text: =
    _foreign_
    data Text: Type

    _foreign_
    concat: Text -> Text -> Text

module option: =
    _inherent_
    data Option (A: Type): Type =
        none (A: Type): Option A
        some (A: Type): A -> Option A

    ;; map (A B: Type) (f: A -> B) (a: Option A): Option B =
    ;;     case a of
    ;;         some ?A ?a => some B (f a)
    ;;         none ?A => none B

module nat: =
    _foreign_
    data Nat: Type

    _foreign_
    add: Nat -> Nat -> Nat

    _foreign_
    subtract: Nat -> Nat -> super.option.Option Nat

    _foreign_
    multiply: Nat -> Nat -> Nat
    
    _foreign_
    divide: Nat -> Nat -> super.option.Option Nat

    _foreign_
    equal: Nat -> Nat -> super.bool.Bool

    _foreign_
    less: Nat -> Nat -> super.bool.Bool

    _foreign_
    less-equal: Nat -> Nat -> super.bool.Bool

    _foreign_
    greater: Nat -> Nat -> super.bool.Bool

    _foreign_
    greater-equal: Nat -> Nat -> super.bool.Bool

    _foreign_
    display: Nat -> super.text.Text

module duple: =
    ;; @Task make inherent as well
    data Duple (A B: Type): Type =
        duple (A B: Type): A -> B -> Duple A B

module triple: =
    data Triple (A B C: Type): Type =
        triple (A B C: Type): A -> B -> C -> Triple A B C

module result: =
    data Result (A E: Type): Type =
        failure (A E: Type): E -> Result A E
        success (A E: Type): A -> Result A E

module list: =
    data List (A: Type): Type =
        ;; @bad naming
        nil (A: Type): List A
        cons (A: Type): A -> List A -> List A
