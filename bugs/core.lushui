;; TEST pass check

;; @Task implement the concept of crates and make `core` (this) a crate
;; @Task write module header
;; module: identity constant compose flip void unit bool text nat nat32 nat64 int int32 int64 â€¦ =

identity (A: Type) (a: A): A = a

constant (A B: Type) (a: A) (b: B): A = a

compose (A B C: Type) (f: A -> B) (g: B -> C) (a: A): C =
    g (f a)

flip (A B C: Type) (f: A -> B -> C) (b: B) (a: A): C =
    f a b

module void: Void =
    data Void: Type =

    ;; absurd (A: Type) (v: Void): A = (case v of) A

;; @Question also `Unit.unit` next to `unit`?
module unit: Unit unit =
    @inherent
    data Unit: Type =
        unit: Unit
    
    use Unit.unit

module bool: Bool false true not =
    @inherent
    data Bool: Type =
        false: Bool
        true: Bool
    
    use Bool.(false true)

    not (b: Bool): Bool = case b of
        false => true
        true => false
    
    ;; @Note not lazy
    ;; if (A: Type) (condition: Bool) (consequent alternate: A): A =
    ;;     case condition of
    ;;         false => alternate
    ;;         true => consequent

    ;; @Note not lazy
    ;; and (b c: Bool): Bool = if Bool b c false

    ;; or (b c: Bool): Bool = if Bool b True c

module text: Text concat ++ =
    @foreign
    data Text: Type

    use concat as ++

    @foreign
    concat: Text -> Text -> Text

;; @Task add the rest of the exposures once we support line breaks inside exposure lists
module nat: Nat add + subtract - panicking-subtract -? multiply * divide / =
    use super.(option.Option bool.Bool text.Text)

    @foreign
    data Nat: Type

    use add as +

    @foreign
    add: Nat -> Nat -> Nat

    use subtract as -

    @foreign
    subtract: Nat -> Nat -> Option Nat

    use panicking-subtract as -?

    ;; @Temporary
    @foreign
    panicking-subtract: Nat -> Nat -> Nat

    use multiply as *

    @foreign
    multiply: Nat -> Nat -> Nat
    
    use divide as /

    @foreign
    divide: Nat -> Nat -> Option Nat

    ;; @Note instead of all those foreign comparison function,
    ;; we could just have a single foreign compare: Nat -> Nat -> Ordering
    ;; except that Ordering would need to be inherent...I know the
    ;; design of inherent (which basically just means "export"/"ffi-export"/"extern")
    ;; is bad; somehow, we need to improve the API of registering inherent bindings!
    ;; as a hacky alternative, we could make compare return an Int (-1, 0, 1) or even a Nat
    ;; (0, 1, 2) and map it afterwards to Ordering

    use equal as ==

    @foreign
    equal: Nat -> Nat -> Bool

    use less as <

    @foreign
    less: Nat -> Nat -> Bool

    use less-equal as =<

    @foreign
    less-equal: Nat -> Nat -> Bool

    use greater as >

    @foreign
    greater: Nat -> Nat -> Bool

    use greater-equal as >=

    @foreign
    greater-equal: Nat -> Nat -> Bool

    @foreign
    display: Nat -> Text

    use super.(bool ordering)

    ;; @Temporary, see comment about foreign compare
    compare (n m: Nat): ordering.Ordering =
        case equal n m of
            bool.true => ordering.equal
            bool.false => case less n m of
                bool.true => ordering.less
                bool.false => ordering.greater

module nat32: Nat32 =
    @foreign
    data Nat32: Type

module nat64: Nat64 =
    @foreign
    data Nat64: Type

module int: Int =
    @foreign
    data Int: Type

module int32: Int32 =
    @foreign
    data Int32: Type

module int64: Int64 =
    @foreign
    data Int64: Type

module duple: Duple duple =
    ;; @Task make inherent as well
    data Duple (A B: Type): Type =
        duple (A B: Type): A -> B -> Duple A B

    use Duple.duple

module triple: Triple triple =
    data Triple (A B C: Type): Type =
        triple (A B C: Type): A -> B -> C -> Triple A B C

    use Triple.triple

module option: Option none some =
    @inherent
    data Option (A: Type): Type =
        none (A: Type): Option A
        some (A: Type): A -> Option A

    use Option.(none some)

    ;; map (A B: Type) (f: A -> B) (a: Option A): Option B =
    ;;     case a of
    ;;         some \_ \a => some B (f a)
    ;;         none \_ => none B

module result: Result failure success =
    data Result (A E: Type): Type =
        failure (A E: Type): E -> Result A E
        success (A E: Type): A -> Result A E

    use Result.(failure success)

module list: List nil cons =
    data List (A: Type): Type =
        ;; @Note bad naming
        nil (A: Type): List A
        cons (A: Type): A -> List A -> List A

    use List.(nil cons)

;; @Question tuple backed by List or by Vector in core (or both implementations)?
module tuple: Tuple nil cons =
    use super.list.(List self)

    data Tuple (L: List Type): Type =
        nil: Tuple (list.nil Type)
        cons (A: Type) (L: List Type): A -> Tuple L -> Tuple (list.cons Type A L)

    use Tuple.(nil cons)

;; @Question tuple backed by List or by Vector in core (or both implementations)?
module tuple': Tuple nil cons =
    use super.vector.(Vector self)
    use super.nat.(Nat +)

    data Tuple (n: Nat) (L: Vector n Type): Type =
        nil: Tuple 0 (vector.nil Type)
        cons (A: Type) (n: Nat) (L: Vector n Type): A -> Tuple n L -> Tuple (+ n 1) (vector.cons n Type A L)

    use Tuple.(nil cons)

module vector: Vector nil cons =
    use super.nat.(Nat +)

    data Vector (n: Nat) (A: Type): Type =
        ;; @Note bad naming
        nil (A: Type): Vector 0 A
        cons (n: Nat) (A: Type): A -> Vector n A -> Vector (+ n 1) A

    use Vector.(nil cons)

module ordering: Ordering less equal greater invert =
    data Ordering: Type =
        less: Ordering
        equal: Ordering
        greater: Ordering
    
    use Ordering.(less equal greater)

    invert (o: Ordering): Ordering = case o of
        less => greater
        equal => equal
        greater => less
