;; TEST ignore

False: Type = (P: Type) -> P

negate (Phi: Type): Type = Phi -> False
power (S: Type): Type = S -> Type

U: Type = (X: Type) -> (power (power X) -> X) -> power (power X)

data HOLE: Type =

tau (t: power (power U)) (X: Type) (f: power (power X) -> X) (p: power X): HOLE =
    t (\(x: U) => p (f (x X f)))

sigma (s: U): HOLE = s U (\(t: power (power U)) => tau t)

Delta (y: U): Type = negate ((p: power U) -> sigma y p -> p (tau (sigma y)))
Omega: Type = tau (\(p: power U) => (x: U) -> sigma x p -> p x)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

main: HOLE = (\(zero: (p: power U) -> ((x: U) -> sigma x p -> p x) -> p Omega) => (zero Delta (\(x: U) (two: sigma x Delta) (three: (p: power U) -> sigma x p -> p (tau (sigma x))) => three Delta two (\(p: power U) => three (\(y: U) => p (tau (sigma y))))))(\(p: power U) => zero (\(y: U) => p (tau (sigma y)))))(\(p: power U) (one: (x: U) -> sigma x p -> p x) => one Omega (\(x: U) => one (tau (sigma x))))

