; The grammar of the Lushui programming language.
;
; Terminals are not plain text but lexems, those are tokens outputted by the lexer.
; This document is written in an EBNF flavor and
; generated from the documentation comments of the parser. Therefore, do not edit this file directly.
;
; | Notation  | Name                                | Definition or Remarks                                         |
; |-----------|-------------------------------------|---------------------------------------------------------------|
; | `; C`     | Comment                             | Stretches until the end of the line                           |
; | `N ::= R` | Definition                          | Defines non-terminal `A` by rule `R`                          |
; | `A B`     | Sequence                            | Rule `B` immediately followed by rule `A` modulo lexed tokens |
; | `(A)`     | Grouping                            | To escape default precedence                                  |
; | `A | B`   | Ordered Alternative                 | Either `A` or `B` first trying `A` then `B`                   |
; | `A?`      | Option                              | `A` or nothing (Îµ)                                            |
; | `A*`      | Kleene Star (Multiplicity)          | Arbitrarily long sequence of `A`s                             |
; | `A+`      | Kleene Plus (Positive Multiplicity) | Arbitrarily long non-empty sequence of `A`s                   |
; | `"T"`     | Terminal                            | Lexed token by textual content                                |
; | `#T`      | Named Terminal                      | Lexed token by name                                           |
; | `!A`      | Associativity                       | To the left of `::=`                                          |
; | `<!A`     | Negative Look-Behind                |                                                               |

General-Identifier ::= #Identifier | #Punctuation

Declaration ::= (Attribute Line-Break*)* Naked-Declaration
Naked-Declaration ::=
    | Value-Declaration
    | Data-Declaration
    | Module-Declaration
    | Crate-Declaration
    | Use-Declaration
    | Group
Crate-Declaration ::= "crate" #Identifier Line-Break
Group ::= Indentation Declaration* Dedentation

Attribute ::= Regular-Attribute | Documentation-Comment

Regular-Attribute ::= "@" (#Identifier | "(" #Identifier Attribute-Argument* ")")

Attribute-Argument ::= Lower-Attribute-Argument | "(" #Identifier Lower-Attribute-Argument ")"
Lower-Attribute-Argument ::= Path | #Number-Literal | #Text-Literal

Value-Declaration ::=
    #Identifier
    Parameters Type-Annotation?
    ("=" Possibly-Indented-Terminated-Expression | Line-Break)

Data-Declaration ::=
    "data" #Identifier
    Parameters Type-Annotation?
    (Line-Break | "=" Line-Break Indentation (Line-Break | Constructor)* Dedentation)

Module-Declaration ::=
    | Header
    | "module" #Identifier (Line-Break | "=" Line-Break Indentation (Line-Break | Declaration)* Dedentation)
Header ::= "module" "=" Line-Break

Top-Level ::= (Line-Break | Declaration)* #End-Of-Input

Use-Declaration ::= "use" Path-Tree Line-Break

Path-Tree ::= Path | Path "." "(" (Path-Tree | "(" Renaming ")")* ")" | Renaming
Renaming ::= Path "as" General-Identifier

Constructor ::=
    (Attribute Line-Break*)*
    #Identifier Parameters Type-Annotation? Line-Break

Expression ::= Pi-Literal-Or-Lower

Pi-Literal-Or-Lower !right ::=
    ("(" Explicitness #Identifier Type-Annotation ")" | Application-Or-Lower)
    ("->" Pi-Literal-Or-Lower)*

Application-Or-Lower !left ::=
    Lower-Expression
    (Lower-Expression | "(" Explicitness (#Identifier "=")? Expression ")")*

Lower-Expression ::= Attribute* Naked-Lower-Expression
Naked-Lower-Expression ::=
    | Path
    | "Type"
    | #Number-Literal
    | #Text-Literal
    | Typed-Hole
    | Let-In
    | Use-In
    | Lambda-Literal
    | Case-Analysis
    | Do-Block
    | Sequence-Literal
    | "(" Expression ")"
Typed-Hole ::= "?" #Identifier
Sequence-Literal ::= "[" Lower-Expression* "]"

Path ::= Path-Head ("." General-Identifier)*
Path-Head ::= Path-Hanger | General-Identifier
Path-Hanger ::= "crate" | "super" | "self"

Lambda-Literal ::= "\" Parameters Type-Annotation? "=>" Expression

Let-In ::=
    "let" #Identifier Parameters Type_Annotation? "="
    Possibly-Breakably-Indented-Expression "in" Line-Break? Expression

Use-In ::= "use" Path-Tree "in" Line-Break? Expression

Case-Analysis ::= "case" Possibly-Breakably-Indented-Expression "of"
    (Line-Break (Indentation Case* Dedentation)?)?
Case ::= Pattern "=>" Expression

Do-Block ::= "do" Line-Break Indentation Statement* Dedentation
Statement ::= Let-Statement | Use-Declaration | Bind-Statement | Expression-Statement
Let-Statement ::= "let" Value-Declaration
Bind-Statement ::= #Identifier Type-Annotation? "<-" Expression Line-Break
Expression-Statement ::= Expression Line-Break

Parameters ::= Parameter-Group*

Parameter-Group ::=
    | #Identifier
    | "(" Explicitness "field"? #Identifier+ Type-Annotation? ")"

Pattern !left ::=
    Lower-Pattern
    (Lower-Pattern | "(" Explicitness (#Identifier =)? Pattern ")")*

Lower-Pattern ::= Attribute* Naked-Lower-Pattern
Naked-Lower-Pattern ::=
    | Path
    | #Number-Literal
    | #Text-Literal
    | Binder
    | Sequence-Literal-Pattern
    | "(" Pattern ")"
Binder ::= "\" #Identifier
Sequence-Literal-Pattern ::= "[" Lower-Pattern* "]"

Type-Annotation ::= ":" Expression

Possibly-Indented-Terminated-Expression ::=
    | Line-Break Indentation Expression Line-Break? Dedentation
    | Terminated-Expression

Possibly-Breakably-Indented-Expression ::=
    | Line-Break Indentation Expression (Line-Break Dedentation)?
    | Expression

Terminated-Expression ::= Expression (<!Dedentation Line-Break)?

Explicitness ::= ","?

