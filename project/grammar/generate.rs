#!/usr/bin/env -S cargo -Zscript
---
[package]
edition = "2024"
---
//! Extract `grammar` snippets from the parser.

// @Task either make this part of `build.rs` (accepting a flag) or another
// binary of the Cargo package lushui for improved portability and stability.

use std::{fs, path::Path};

const INPUT_BASE_PATH: &str = "../../compiler/parser/src/";
const INPUT_FILE_NAMES: [&str; 5] = [
    "lib.rs",
    "common.rs",
    "declaration.rs",
    "expression.rs",
    "pattern.rs",
];
const OUTPUT_PATH: &str = "lushui.grammar";

const PREAMBLE: &str = "\
; The grammar of the Lushui programming language.
;
; Terminals are not plain text but lexemes, those are tokens outputted by the lexer.
; This document is written in an EBNF flavor and
; generated from the documentation comments of the parser. Therefore, do not edit this file directly.
;
";

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let input_base_path = Path::new(env!("CARGO_MANIFEST_DIR")).join(INPUT_BASE_PATH);

    let mut grammar = String::from(PREAMBLE);
    let mut grammar_snippets = 0;
    let mut non_grammar_snippets = 0;

    for file_name in INPUT_FILE_NAMES {
        let file = fs::read_to_string(input_base_path.join(file_name))?;

        collect_grammar_snippets(
            &file,
            &mut grammar,
            &mut grammar_snippets,
            &mut non_grammar_snippets,
        );
    }

    fs::write(Path::new(env!("CARGO_MANIFEST_DIR")).join(OUTPUT_PATH), grammar)?;

    println!("OK. Collection of grammar snippets successful.");
    println!("  Processed grammar snippets: {grammar_snippets}");
    println!("Skipped non-grammar snippets: {non_grammar_snippets}");

    Ok(())
}

fn collect_grammar_snippets(
    file: &str,
    grammar: &mut String,
    grammar_snippets: &mut u32,
    non_grammar_snippets: &mut u32,
) {
    let mut snippet_state = OutsideCodeSnippet;
    let mut grammar_definition_state = NotCollectedYet;

    for line in file.lines() {
        let line = line.trim_start();
        if let Some(line) = line.strip_prefix("///") {
            let line = line.strip_prefix(" ").unwrap_or(line);

            if let Some(line) = line.strip_prefix("```") {
                snippet_state = if line == "grammar" {
                    match snippet_state {
                        OutsideCodeSnippet => InsideGrammarSnippet,
                        InsideNonGrammarCodeSnippet | InsideGrammarSnippet => unreachable!(),
                    }
                } else {
                    match snippet_state {
                        OutsideCodeSnippet => InsideNonGrammarCodeSnippet,
                        InsideNonGrammarCodeSnippet => {
                            *non_grammar_snippets += 1;
                            OutsideCodeSnippet
                        }
                        InsideGrammarSnippet => {
                            grammar.push('\n');
                            *grammar_snippets += 1;
                            OutsideCodeSnippet
                        }
                    }
                }
            } else {
                if let OutsideCodeSnippet | InsideNonGrammarCodeSnippet = snippet_state {
                    continue;
                }

                *grammar += line;
                grammar.push('\n');
            }
        } else if let Some(line) = line.strip_prefix("//!") {
            if line.contains("| Notation") && line.contains("| Definition") {
                grammar.push(';');
                *grammar += line;
                grammar.push('\n');
                match grammar_definition_state {
                    NotCollectedYet => grammar_definition_state = Collecting,
                    Collecting | Collected => unreachable!(),
                }
            } else {
                match grammar_definition_state {
                    NotCollectedYet | Collected => {}
                    Collecting => {
                        grammar.push(';');
                        *grammar += &line
                            .replace("&vert;", "|")
                            .replace("<code>", "`")
                            .replace("</code>", "`");
                        grammar.push('\n');
                    }
                }
            }
        } else {
            match grammar_definition_state {
                Collected | NotCollectedYet => {}
                Collecting => {
                    *grammar += "\n";
                    grammar_definition_state = Collected
                }
            }
        }
    }

    assert_eq!(snippet_state, OutsideCodeSnippet);
    assert_ne!(grammar_definition_state, Collecting);
}

use SnippetState::*;

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
enum SnippetState {
    OutsideCodeSnippet,
    InsideNonGrammarCodeSnippet,
    InsideGrammarSnippet,
}

use GrammarDefinitionState::*;

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
enum GrammarDefinitionState {
    NotCollectedYet,
    Collecting,
    Collected,
}
