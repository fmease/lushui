#!/usr/bin/sh
//usr/bin/env rustc $0 ; ./generate ; rm ./generate ; exit
//! Extract `grammar` snippets from the parser.

// @Task either make this part of `build.rs` (accepting a flag) or another
// binary of the Cargo package lushui for improved portability and stability.

use std::{fs, path::Path};

const PARSER_PATH: &str = "../../compiler/parser/src/lib.rs";
const OUTPUT_PATH: &str = "lushui.grammar";

const PREAMBLE: &str = "\
; The grammar of the Lushui programming language.
;
; Terminals are not plain text but lexems, those are tokens outputted by the lexer.
; This document is written in an EBNF flavor and
; generated from the documentation comments of the parser. Therefore, do not edit this file directly.
;
";

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let program_directory_path = Path::new(file!()).parent().unwrap();
    let parser = fs::read_to_string(program_directory_path.join(PARSER_PATH))?;

    let mut snippet_state = OutsideCodeSnippet;
    let mut grammar_snippets = 0;
    let mut other_snippets = 0;
    let mut grammar_definition_state = NotCollectedYet;

    let mut grammar = String::from(PREAMBLE);

    for line in parser.lines() {
        let line = line.trim_start();
        if let Some(line) = line.strip_prefix("///") {
            let line = line.strip_prefix(" ").unwrap_or(line);

            match line.strip_prefix("```") {
                Some(line) => {
                    snippet_state = if line == "grammar" {
                        match snippet_state {
                            OutsideCodeSnippet => InsideGrammarSnippet,
                            InsideOtherCodeSnippet | InsideGrammarSnippet => unreachable!(),
                        }
                    } else {
                        match snippet_state {
                            OutsideCodeSnippet => InsideOtherCodeSnippet,
                            InsideOtherCodeSnippet => {
                                other_snippets += 1;
                                OutsideCodeSnippet
                            }
                            InsideGrammarSnippet => {
                                grammar.push('\n');
                                grammar_snippets += 1;
                                OutsideCodeSnippet
                            }
                        }
                    };
                }
                None => {
                    if let OutsideCodeSnippet | InsideOtherCodeSnippet = snippet_state {
                        continue;
                    }

                    grammar += line;
                    grammar.push('\n');
                }
            }
        } else if let Some(line) = line.strip_prefix("//!") {
            if line.contains("| Notation") && line.contains("| Definition") {
                grammar.push(';');
                grammar += line;
                grammar.push('\n');
                match grammar_definition_state {
                    NotCollectedYet => grammar_definition_state = Collecting,
                    Collecting | Collected => unreachable!(),
                }
            } else {
                match grammar_definition_state {
                    NotCollectedYet | Collected => {}
                    Collecting => {
                        grammar.push(';');
                        grammar += &line
                            .replace("&vert;", "|")
                            .replace("<code>", "`")
                            .replace("</code>", "`");
                        grammar.push('\n');
                    }
                }
            }
        } else {
            match grammar_definition_state {
                Collected => {}
                NotCollectedYet => unreachable!(),
                Collecting => {
                    grammar += "\n";
                    grammar_definition_state = Collected
                }
            }
        }
    }

    assert_eq!(snippet_state, OutsideCodeSnippet);
    assert_eq!(grammar_definition_state, Collected);

    fs::write(program_directory_path.join(OUTPUT_PATH), grammar)?;

    println!(
        "processed {} ‘grammar’ snippets and skipped {} non-‘grammar’ snippets",
        grammar_snippets, other_snippets
    );

    Ok(())
}

use SnippetState::*;

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
enum SnippetState {
    OutsideCodeSnippet,
    InsideOtherCodeSnippet,
    InsideGrammarSnippet,
}

use GrammarDefinitionState::*;

#[derive(Clone, Copy, PartialEq, Eq, Debug)]
enum GrammarDefinitionState {
    NotCollectedYet,
    Collecting,
    Collected,
}
