; The grammar of the Lushui programming language.
;
; Terminals are not plain text but lexemes, those are tokens outputted by the lexer.
; This document is written in an EBNF flavor and
; generated from the documentation comments of the parser. Therefore, do not edit this file directly.
;
; | Notation  | Name                                | Definition or Remark                                          |
; |-----------|-------------------------------------|---------------------------------------------------------------|
; | `; C`     | Comment                             | Stretches until the end of the line                           |
; | `N ::= R` | Definition                          | Defines non-terminal `A` by rule `R`                          |
; | `A B`     | Sequence                            | Rule `B` immediately followed by rule `A` modulo lexed tokens |
; | `(A)`     | Grouping                            | To escape default precedence                                  |
; | `A | B`   | Ordered Alternative                 | Either `A` or `B` first trying `A` then `B`                   |
; | `A?`      | Option                              | `A` or nothing (ε)                                            |
; | `A*`      | Kleene Star (Multiplicity)          | Arbitrarily long sequence of `A`s                             |
; | `A+`      | Kleene Plus (Positive Multiplicity) | Arbitrarily long non-empty sequence of `A`s                   |
; | `"T"`     | Terminal                            | Lexed token by textual content                                |
; | `#T`      | Named Terminal                      | Lexed token by name                                           |
; | `(> A)`   | Positive Look-Ahead                 | Bounded                                                       |
; | `(< A)`   | Positive Look-Behind                | Bounded                                                       |
; | `⟪M⟫`     | Metavariable                        | Draws from a finite domain                                    |
; | `⟪⟪ L ⟫⟫` | Metalanguage expression             | Mirrors the object language                                   |

Use-Path-Tree ::=
    | Path
    | Path "." "(" (Use-Path-Tree ",")* ")"
    | Path "as" Identifier

Path ::= Path-Head ("." Identifier)*

Path-Head ::= Path-Hanger | Identifier
Path-Hanger ::= "extern" | "topmost" | "super" | "self"

Params ::= Param*
Param ::=
    | "'"? Local-Binder
    | "'"? (Local-Binder Type-Annotation? ")"
    | "[" (Local-Binder ":")? Expr "]"

Sequence-Literal-Or-Bracketed-⟪Item⟫ ::= (Path ".")? "(" (⟪Item⟫ ",")* ")"

Record-Literal-⟪Item⟫ ::=
    "{"
    ; @Task generalize #Word to "paths" (i.e. identifiers with "." OR "::" seps!)
    (#Word ("=" ⟪Item⟫)? ",")* ; @Task make trailing comma optional & don't allow it if ";" follows
    (";" ⟪Item⟫)?
    "}"

Application-⟪Item⟫-Or-Lower ::= Lower-⟪Item⟫ ⟪Item⟫-Argument*
⟪Item⟫-Argument ::=
    "'"?
    (Lower-⟪Item⟫ | "(" (#Word "=")? ⟪Item⟫ ")")

Path-Or-Namespaced-⟪Item⟫-Literal ::= Path ("." ⟪Item⟫-Literal)?
⟪Item⟫-Literal ::=
    | #Number-Literal
    | #Text-Literal
    | Sequence-Literal-⟪Item⟫
    | Record-Literal-⟪Item⟫

Type-Annotation ::= ":" Expr

Attr ::= Regular-Attr | #Documentation-Comment

Regular-Attr ::= "@" (#Word | "(" #Word Attr-Argument* ")")

Attr-Argument ::= Lower-Attr-Argument | "(" #Word Lower-Attr-Argument ")"
Lower-Attr-Argument ::= Path | #Number-Literal | #Text-Literal

Identifier ::= #Word | #Symbol

Local-Binder ::= #Word | "_"

; #Start-Of-Input is not actually emitted by the lexer, the parser needs to bound-check instead.
;
Terminator ::= #Line-Break
    | (> #Dedentation | #End-Of-Input)
    | (< #Start-Of-Input | #Line-Break | #Dedentation)

Wildcard ::= Silent-Wildcard | Signaling-Wildcard
Silent-Wildcard ::= "_"
Signaling-Wildcard ::= "?" #Word

⟪⟪ Item ::= "Expr" | "Pat" ⟫⟫

Top-Level ::= (#Line-Break | Decl)* #End-Of-Input

Decl ::= (Attr #Line-Break*)* Bare-Decl
Bare-Decl ::=
    | Function-Decl
    | Data-Decl
    | Module-Decl
    | Use-Decl
    | Given-Decl

Function-Decl ::=
    #Word
    Params Type-Annotation?
    ("=" Expr)?
    Terminator

Data-Decl ::=
    Data-Kind
    #Word
    Params Type-Annotation?
    ("of" (#Indentation (Terminator | Decl)* #Dedentation)?)?
    Terminator
Data-Kind ::= "data" | "record" | "trait"

Module-Decl ::=
    | Module-Header
    | "module" #Word ("of" (#Indentation (Terminator | Decl)* #Dedentation)?)? Terminator
Module-Header ::= "module" Terminator

Use-Decl ::= "use" Use-Path-Tree Terminator

Given-Decl ::=
    "given"
    #Word
    Params Type-Annotation?
    Given-Body?
    Terminator
Given-Body ::=
    | "of" (#Indentation (Terminator | Decl)* #Dedentation)?
    | "=" Expr

Expr ::= Shorthand-Quantified-Type-Or-Lower

; Among other things, the grammar for pretty printers differs from the one for parsers
; in that `Shorthand-Quantified-Type-Or-Lower` also includes several complex (in the sense of
; containing further expressions) `Lower-Expr`s namely let- and use-bindings, lambda literals,
; case analyses and do blocks.
;
Shorthand-Quantified-Type-Or-Lower ::=
    Application-Expr-Or-Lower
    Quantifier
    Shorthand-Quantified-Type-Or-Lower
Quantifier ::= "->" | "**"

Application-Expr-Or-Lower ::= Lower-Expr Expr-Argument*
Expr-Argument ::=
    "'"?
    (Lower-Expr | "(" (#Word "=")? Expr ")")

; ; The left-recursive version of the rule above is unsuitable for a recursive descent parser.
; ; However, it is usable for pretty printers.
;
; Application-Expr-Or-Lower ::= Application-Expr-Or-Lower? Expr-Argument*
; Expr-Argument ::=
;     | Lower-Expr
;     | "'"? "(" (#Word "=")? Expr ")"

Lower-Expr ::= Attr* Bare-Lower-Expr
Bare-Lower-Expr ::= Lowest-Expr ("::" Identifier)*
Lowest-Expr ::=
    | Wildcard
    | #Number-Literal
    | #Text-Literal
    | Let-Binding
    | Use-Binding
    | Lambda-Literal
    | Case-Analysis
    | Do-Block
    | Quantified-Type
    | Sequence-Literal-Or-Bracketed-Expr
    | Record-Literal-Expr
    | Path-Or-Namespaced-Expr-Literal

Lambda-Literal ::= "for" Params Type-Annotation? "=>" Expr

Quantified-Type ::= "For" Param* Quantifier Expr

Let-Binding ::=
    "let" Local-Binder Params Type-Annotation?
    ("=" Expr)?
    #Line-Break?
    "in" Expr

Use-Binding ::=
    "use" Use-Path-Tree
    #Line-Break?
    "in" Expr

Case-Analysis ::= "case" Expr "of" (#Indentation Case* #Dedentation)?
Case ::= Pat "=>" Expr Terminator

Do-Block ::= "do" #Indentation Statement* #Dedentation
Statement ::= Let-Statement | Use-Decl | Expr-Statement
Let-Statement ::=
    "let" Local-Binder Param* Type-Annotation?
    Binding-Mode
    Expr Terminator
Expr-Statement ::= Expr Terminator
Binding-Mode ::=  "=" | "<-"

Pat ::=
    | Binder
    | Lower-Pat Pat-Argument*
Binder ::= "let" Local-Binder
Pat-Argument ::=
    "'"?
    (Lower-Pat | "(" (#Word "=")? Pat ")")

Lower-Pat ::= Attr* Bare-Lower-Pat
Bare-Lower-Pat ::=
    | Wildcard
    | #Number-Literal
    | #Text-Literal
    | Sequence-Literal-Or-Bracketed-Pat
    | Record-Literal-Pat
    | Path-Or-Namespaced-Pat-Literal

