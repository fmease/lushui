; The grammar of the Lushui programming language.
;
; Terminals are not plain text but lexems, those are tokens outputted by the lexer.
; This document is written in an EBNF flavor and
; generated from the documentation comments of the parser. Therefore, do not edit this file directly.
;
; | Notation  | Name                                | Definition or Remark                                          |
; |-----------|-------------------------------------|---------------------------------------------------------------|
; | `; C`     | Comment                             | Stretches until the end of the line                           |
; | `N ::= R` | Definition                          | Defines non-terminal `A` by rule `R`                          |
; | `A B`     | Sequence                            | Rule `B` immediately followed by rule `A` modulo lexed tokens |
; | `(A)`     | Grouping                            | To escape default precedence                                  |
; | `A | B`   | Ordered Alternative                 | Either `A` or `B` first trying `A` then `B`                   |
; | `A?`      | Option                              | `A` or nothing (ε)                                            |
; | `A*`      | Kleene Star (Multiplicity)          | Arbitrarily long sequence of `A`s                             |
; | `A+`      | Kleene Plus (Positive Multiplicity) | Arbitrarily long non-empty sequence of `A`s                   |
; | `"T"`     | Terminal                            | Lexed token by textual content                                |
; | `#T`      | Named Terminal                      | Lexed token by name                                           |
; | `(> A)`   | Positive Look-Ahead                 |                                                               |
; | `(< A)`   | Positive Look-Behind                |                                                               |

Top-Level ::= (#Line-Break | Declaration)* #End-Of-Input

Declaration ::= (Attribute #Line-Break*)* Bare-Declaration
Bare-Declaration ::=
    | Function-Declaration
    | Data-Declaration
    | Module-Declaration
    | Use-Declaration

Function-Declaration ::=
    #Word
    Parameters Type-Annotation?
    ("=" Expression)?
    Terminator

Data-Declaration ::=
    "data" #Word
    Parameters Type-Annotation?
    ("of" (#Indentation (Terminator | Constructor)* #Dedentation)?)?
    Terminator

Module-Declaration ::=
    | Header
    | "module" #Word ("of" (#Indentation (Terminator | Declaration)* #Dedentation)?)? Terminator
Header ::= "module" Terminator

Use-Declaration ::= "use" Use-Path-Tree Terminator

Use-Path-Tree ::=
    | Path
    | Path "." "(" (Use-Path-Tree | "(" Renaming ")")* ")"
    | Renaming
Renaming ::= Path "as" Identifier

Constructor ::=
    (Attribute #Line-Break*)*
    #Word Parameters Type-Annotation?
    ("=" Expression)?
    Terminator

Expression ::= Shorthand-Quantified-Type-Or-Lower

; Among other things, the grammar for pretty printers differs from the one for parsers
; in that `Shorthand-Quantified-Type-Or-Lower` also includes several complex (in the sense that they
; contain further expressions) `Lower-Expression`s namely let- and use-bindings, lambda literals,
; case analyses and do blocks.
;
Shorthand-Quantified-Type-Or-Lower ::=
    Application-Expression-Or-Lower
    Quantifier
    Shorthand-Quantified-Type-Or-Lower
Quantifier ::= "->" | "**"

Application-Expression-Or-Lower ::= Lower-Expression Expression-Argument*
Expression-Argument ::=
    Explicitness
    (Lower-Expression | "(" (#Word "=")? Expression ")")

; ; The left-recursive version of the rule above is unsuitable for a recursive descent parser.
; ; However, it is usable for pretty printers.
;
; Application-Expression-Or-Lower ::= Application-Expression-Or-Lower? Expression-Argument*
; Expression-Argument ::=
;     | Lower-Expression
;     | Explicitness "(" (#Word "=")? Expression ")"

Lower-Expression ::= Attribute* Bare-Lower-Expression
Bare-Lower-Expression ::= Lowest-Expression ("::" Identifier)*
Lowest-Expression ::=
    | #Number-Literal
    | #Text-Literal
    | Typed-Hole
    | Let-Binding
    | Use-Binding
    | Lambda-Literal
    | Case-Analysis
    | Do-Block
    | Quantified-Type
    | Sequence-Literal-Expression
    | Path-Or-Namespaced-Literal-Expression
    | "(" Expression ")"
Typed-Hole ::= "?" #Word

Path ::= Path-Head ("." Identifier)*
Path-Head ::= Path-Hanger | Identifier
Path-Hanger ::= "extern" | "topmost" | "super" | "self"

Lambda-Literal ::= "for" Parameters Type-Annotation? "=>" Expression

Quantified-Type ::= "For" Parameter* Quantifier Expression

Let-Binding ::=
    "let" #Word Parameters Type-Annotation?
    ("=" Expression)?
    #LineBreak?
    "in" Expression

Use-Binding ::=
    "use" Use-Path-Tree
    #LineBreak?
    "in" Expression

Case-Analysis ::= "case" Expression "of" (#Indentation Case* #Dedentation)?
Case ::= Pattern "=>" Expression Terminator

Do-Block ::= "do" #Indentation Statement* #Dedentation
Statement ::= Let-Statement | Use-Declaration | Expression-Statement
Let-Statement ::= "let" #Word Parameter* Type-Annotation? Binding-Mode Expression Terminator
Expression-Statement ::= Expression Terminator
Binding-Mode ::=  "=" | "<-"

Parameters ::= Parameter*

Parameter ::= Explicitness Bare-Parameter
Bare-Parameter ::= #Word | "(" #Word Type-Annotation? ")"

Pattern ::= Lower-Pattern Pattern-Argument*
Pattern-Argument ::=
    Explicitness
    (Lower-Pattern | "(" (#Word "=")? Pattern ")")

Lower-Pattern ::= Attribute* Bare-Lower-Pattern
Bare-Lower-Pattern ::=
    | #Number-Literal
    | #Text-Literal
    | Binder
    | Sequence-Literal-Pattern
    | Path-Or-Namespaced-Literal-Pattern
    | "(" Pattern ")"
Binder ::= "\" #Word

Sequence-Literal-Expression ::= (Path ".")? "[" Lower-Expression* "]"
Sequence-Literal-Pattern ::= (Path ".")? "[" Lower-Pattern* "]"

Application-⟪Item⟫-Or-Lower ::= Lower-⟪Item⟫ ⟪Item⟫-Argument*
⟪Item⟫-Argument ::=
    Explicitness
    (Lower-⟪Item⟫ | "(" (#Word "=")? ⟪Item⟫ ")")

Path-Or-Namespaced-Literal-Expression ::=
    Path
    ("." (#Number-Literal | #Text-Literal | Sequence-Literal-Expression))?
Path-Or-Namespaced-Literal-Pattern ::=
    Path
    ("." (#Number-Literal | #Text-Literal | Sequence-Literal-Pattern))?

Type-Annotation ::= ":" Expression

Attribute ::= Regular-Attribute | Documentation-Comment

Regular-Attribute ::= "@" (#Word | "(" #Word Attribute-Argument* ")")

Attribute-Argument ::= Lower-Attribute-Argument | "(" #Word Lower-Attribute-Argument ")"
Lower-Attribute-Argument ::= Path | #Number-Literal | #Text-Literal

Identifier ::= #Word | #Symbol

; #Start-Of-Input is not actually emitted by the lexer, the parser needs to bound-check instead.
;
Terminator ::= #Line-Break
    | (> #Dedentation | #End-Of-Input)
    | (< #Start-Of-Input | #Line-Break | #Dedentation)

Explicitness ::= "'"?

